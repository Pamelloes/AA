================================================================
==    HIGH LEVEL BINARY LANGUAGE SPECIFICATION VERSION 0.1    ==
================================================================

----
I. PREFACE
  I think it's import that I start this document with a brief explanation of some
  sorts. First and foremost: I have no business writing this document. I am an
  experienced hobbyist programmer and basically have no idea what I'm doing here.
  If this language ever picks up steam (which I sincerely doubt), maybe I could
  get this peer reviewed and fix the flaws in my language design and terminology.
  The sole reason that this project exists is I had some ideas one day that
  required a computer to be able to interpret any sequence of randomly generated
  bytes as a valid program and nothing to my knowledge existed that could do
  that, so I decided to write my own language that could. From here on out, I will
  try to keep things as professional as possible (within the constraints of my
  abilities).

  A. BINARY REPRESENTATION
    All parts of the HLB language are expressed in binary unless expressly stated
    otherwise. Throughout this document, the number one (1) will refer to the one
    bit in the on state, the number zero (0) will refer to one bit in an off state,
    and the letter "X" will be used to refer to one bit of ambiguous value when
    expressing binary code. Brackets ([]) with the name of a construct can be used
    to express that a variation of that construct is to be inserted. Details of how
    exactly the construct will be expressed will be provided in the description of
    the binary code.

----
II. TABLE OF CONTENTS
  I. PREFACE
    A. BINARY REPRESENTATION
  II. TABLE OF CONTENTS 
  III. LANGUAGE OVERVIEW
  IV. VARIABLES
    A. TYPES
    B. NAMES
  V. FUNCTIONS
  VI. FUNCTIONAL COMMANDS
  VII. CLASSES
  VII. SCOPE

----
III. LANGUAGE OVERVIEW

----
IV. VARIABLES
  Almost all constructs in HLB are variables. A variable has two parts: a type and a
  name (see IV.A-B). A variable is referred to using the following structure:

    [TYPE][NAME]
  
  Depending on the situation, the appropriate type form will be used. It is important
  to note that a variable's value is only preserved within its scope (see `SCOPE`).
  Furthermore variables of different type are considered to be unique so a function
  variable and a number variable sharing the same name will exist independently of each
  other.

  All possible variables are assumed to be initialized at all times. First order variables'
  default values and initialization process will be addressed in sections V and VI. Second
  order default values are as follows: all numbers will have a default value of 0 and
  instances will have a default value of the Null Instance (see `NULL INSTANCE`).

  A. TYPES
    There are four types of variables as follows:

       BIT CODE | SHORT CODE |   NAME   |  ORDER
      -------------------------------------------
          00    |     0      | FUNCTION | FIRST
          01    |     0      |  NUMBER  | SECOND
          10    |     1      | INSTANCE | SECOND
          11    |     1      |   CLASS  | FIRST

    The four types can be split into first and second order types. In some parts of a program
    only one order of types is allowed. In that case, then the one bit code is used to
    identify a type. If both type orders are valid, then the two bit code is used. In a
    limited set of situations, the type is implied and no type will be expressed. In such
    situations, the lack of type codes will be explicitly stated and elucidated upon.

    First and second order types have several key differences. First and foremost, a first
    order type can be created when type declarations are restricted to first order types
    only. In addition, there is no explicit command for assigning a value to a variable with
    a first order type. Instead the assignation is implicit with the declaration of the
    variable's existence and is assumed to immediately follow. While technically legal,
    assigning a new value to a first order variable is considered very bad form. Finally,
    first order variables have special scope considerations (see `SCOPE`). Second order
    type variables can be created whenever they are allowed. Values are assigned to second
    order variables via the assignment command and changing of their value is encouraged.
    Second order variables have no special scope considerations.

  B. NAMES
    All variables are assigned a name. Names can have one of the following formats:

      0XXXXXXXXXXXXXXXX
      1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

    The first method of expressing a name is by prefacing the name with 0 and then
    specifying sixteen bits that composite the name. Alternatively, a name can be
    prefaced by a 1 allowing for the name to be made of thirty two bits. Note that sixteen
    bit names and thirty two bit names are independent of each other. One cannot refer to
    a sixteen bit name with a sixteen bit name. This means it is possible to specify slightly
    more than four billion names (4,295,032,832 to be exact).

----
V. FUNCTIONS
  A function is the unit in HLB. Functions are the only location where actual code can be written.
  Functions are invoked either directly by the interpreter to start the program or by another
  function. Functions are first order variables and therefore have special rules to their use. A
  more detailed comparison between first order and second order variables can be found in IV.A. A
  function can only have a value assigned to it when the valid variable types are restricted to
  first order types only. It bears noting that it is very bad form to reassign a function's
  value. Functions are assigned as follows:

    [VARIABLE]XXXX[FUNCTIONAL COMMAND LIST][UNAMBIGUOUS RETURN]

  The assignation of a function has three parts. First the function variable is stated determining
  what function variable is being assigned to. Following the variable declaration are four bits
  constituting an unsigned integer with a value from 0 to 15. This number is how many parameters
  are passed to the function on invocation. Subsequently, the functional commands that constitute
  the function are listed. Functional commands are discussed in depth in `FUNCTIONAL COMMANDS`.
  Note that within the functional command list both first and second order types are permitted.
  The function assignation ends with an unambiguous return command. An unambiguous return command
  is a return command not within an if command and therefore must be executed if all previous
  commands finish execution.
    