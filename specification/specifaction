================================================================
==    HIGH LEVEL BINARY LANGUAGE SPECIFICATION VERSION 0.1    ==
================================================================

----
I. PREFACE
  I think it's import that I start this document with a brief explanation of some
  sorts. First and foremost: I have no business writing this document. I am an
  experienced hobbyist programmer and basically have no idea what I'm doing here.
  If this language ever picks up steam (which I sincerely doubt), maybe I could
  get this peer reviewed and fix the flaws in my language design and terminology.
  The sole reason that this project exists is I had some ideas one day that
  required a computer to be able to interpret any sequence of randomly generated
  bytes as a valid program and nothing to my knowledge existed that could do
  that, so I decided to write my own language that could. From here on out, I will
  try to keep things as professional as possible (within the constraints of my
  abilities).

  A. BINARY REPRESENTATION
    All parts of the HLB language are expressed in binary unless expressly stated
    otherwise. Throughout this document, the number one (1) will refer to the one
    bit in the on state, the number zero (0) will refer to one bit in an off state,
    and the letter "X" will be used to refer to one bit of ambiguous value when
    expressing binary code. Brackets ([]) with the name of a construct can be used
    to express that a variation of that construct is to be inserted. Details of how
    exactly the construct will be expressed will be provided in the description of
    the binary code.

----
II. TABLE OF CONTENTS
  I. PREFACE
    A. BINARY REPRESENTATION
  II. TABLE OF CONTENTS 
  III. LANGUAGE OVERVIEW
  IV. VARIABLES
    A. TYPES
    B. NAMES
  V. FUNCTIONS
  VI. FUNCTIONAL STATEMENTS
  VII. CONTROL STATEMENTS
  VIII. CLASSES
  IX. SCOPE

----
III. LANGUAGE OVERVIEW

----
IV. VARIABLES
  Almost all constructs in HLB are variables. A variable has two parts: a type and a
  name (see IV.A-B). A variable is referred to using the following structure:

    [TYPE][NAME]
  
  Depending on the situation, the appropriate type form will be used. It is important
  to note that a variable's value is only preserved within its scope (see `SCOPE`).
  Furthermore variables of different type are considered to be unique so a function
  variable and a number variable sharing the same name will exist independently of each
  other.

  All possible variables are assumed to be initialized at all times. First order variables'
  default values and initialization process will be addressed in sections V and VI. Second
  order default values are as follows: all numbers will have a default value of 0 and
  instances will have a default value of the Null Instance (see `NULL INSTANCE`).

  A. TYPES
    There are four types of variables as follows:

       BIT CODE | SHORT CODE |   NAME   |  ORDER
      -------------------------------------------
          00    |     0      | FUNCTION | FIRST
          01    |     0      |  NUMBER  | SECOND
          10    |     1      | INSTANCE | SECOND
          11    |     1      |   CLASS  | FIRST

    The four types can be split into first and second order types. First order types
    represent constructs that the program can be interacted with but not changed. Second
    order types can be both interacted with and manipulated. In some parts of a program
    only one order of types is allowed. In that case, then the one bit code is used to
    identify a type. If both type orders are valid, then the two bit code is used. In a
    limited set of situations, the type is implied and no type will be expressed. In such
    situations, the lack of type codes will be explicitly stated and elucidated upon.

  B. NAMES
    All variables are assigned a name. Names can have one of the following formats:

      0XXXXXXXXXXXXXXXX
      1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

    The first method of expressing a name is by prefacing the name with 0 and then
    specifying sixteen bits that composite the name. Alternatively, a name can be
    prefaced by a 1 allowing for the name to be made of thirty two bits. Note that sixteen
    bit names and thirty two bit names are independent of each other. One cannot refer to
    a sixteen bit name with a sixteen bit name. This means it is possible to specify a bit
    more than four billion names (4,295,032,832 to be exact).
    