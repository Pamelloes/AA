================================================================
==    ADVANCED ASSEMBLY LANGUAGE SPECIFICATION VERSION 0.4    ==
================================================================

----
I. Preface

  Advanced Assembly is a programming language roughly resembling an assembly programming languages. However, unlike standard assembly languages, Advanced Assembly is not designed to be run on a specific processor. Instead, it has been designed so that any series of bits--any combination of "1" and "0"--is a valid program.
  A key design element of Advanced Assembly is that it discards the standard grouping of eight bits into a byte--this allows Advanced Assembly to be able to interpret any series of bits as a program but also makes it impossible to run directly on a processor. Instead, Advanced Assembly code must be run via an interpreter, ostensibly on a virtual machine.
  During earlier stages of development, Advanced Assembly was called High Level Binary, and, in addition to being able to interpret any series of bits as a program, was intended to be able to express a myriad of high-level programming features reminiscent of programming languages like C++ or Python. However, as development progressed, it became apparent that in order to implement many features the syntax of the language would become incredibly complicated and that they could be replicated in code within a simpler language. As such, the language was rapidly simplified until by the time the first complete language specification was planned out, High Level Binary no longer represented the "high level" programming languages it was originally intended to emulate; instead, the programming language appeared to be a permutation of a typical assembly language. Therefore, the decision was made to rename the language Advanced Assembly to indicate that it facilitated a different feature set than standard assembly languages while distancing the association with so-called high level programming languages.
  The simplification of Advanced Assembly has led to several features that were believed to be very important to no longer directly included in the programming language. These features, such as the Object Oriented Programming paradigm, will therefore be provided as "extensions." Separate specification documents will be drafted that define how these features are to work and a reference implementation of them shall be created solely using Advanced Assembly code. Therefore in a program where one of these features is desired, the extension can be used by invoking the extension as one of the first actions of a program. All subsequent statements will than have access to the now-loaded extension's feature set. As of the writing of this document, no extensions have been drafted or implemented.
  
----
II. Table of Contents

  I.             Preface
  II.            Table of Contents
  III.           Notation
   A.             Opcodes
  IV.            Strings
  V.             Data Types
   A.             Integers
   B.             Floats
  VI.            Namespaces
  VII.           Statements
   A.             Literal Statements
   B.             Functional Statements
    1.             Namespace Statements
    2.             Mathematical Statements
  VIII.          Actions
  IX.            Program Control Flow

  Appendix A.    Opcodes
  Appendix B.    Conceptual Opcodes
  Appendix C.    Compiler Notes
  Appendix D.    Memory Management Notes

----
III. Notation

  Advanced Assembly, as a quasi-assembly language, is programmed by specifying the value of a series of bits. A bit is the smallest unit of memory within a computer and can either have a value of "0" or "1." Throughout this document it is understood that "1" and "0" do not refer to their numerical value. Instead, "1" represents a single bit with a value of one and "0" represents a single bit with a value of zero. All other arabic numerals are understood to be referring to their numeric value. In the event that "1" or "0" is used in conjunction with other arabic numerals, it is understood that the "1" or "0" will not be representing their numeric value and not a computer bit.
  Under some circumstances, expressing numbers (such as one hundred) in arabic numerals will only use the symbols "1" and "0". In such cases, the number will be written out "one hundred." Therefore, if "100" is encountered it is understood that "100" is referring to three, sequential bits with values of one, zero, and zero respectively.

Examples:
     0  Refers to a single bit with a value of zero
     8  Refers to the number eight
    10  Refers to two, sequential bits with values of one and zero respectively
    15  Refers to the number fifteen
  1425  Refers to the number one thousand, four hundred, twenty-five
  1000  Refers to four, sequential bits with values of one, zero, zero, and zero respectively

NOTE: In many documents strings of bits may be grouped into sets of four and expressed in hexadecimal--allowing two hexadecimal digits to express the value of a byte. However, since Advanced Assembly does not group bits into larger groups of regular size, this notation will not be used. Whenever strings of bits are to be expressed, they will be expressed using the previously outlined "1" and "0" notation.

A. Opcodes

  While the Advanced Assembly programming language is made up of series of 1's and 0's, such notation can be difficult for humans to read. Furthermore, the character "1" is not equal to a single bit a value of one. Instead, characters are made up of groups of 8 bits so rendering an Advanced Assembly program as text would produce gibberish.
  In order to solve this problem and allow for easier programming, the various aspects of Advanced Assembly are defined through mnemonics--several character abbreviations that directly transfer to a specific series of bits. A separate program can then be used to turn a text file consisting of these mnemonics into their corresponding bits. These mnemonics are collectively referred to as "opcodes" and are defined throughout the specification. A complete list of all the defined opcodes in Advanced Assembly and their corresponding values can be found in Appendix A.
  In Advanced Assembly, groups of opcodes are used in conjunction with arbitrary series of bits in predictable patterns to express more complex concepts than a set of opcodes that directly correspond with a series of bits. These concepts, such as strings, often come up in multiple places throughout the specification where it is more meaningful to refer to them by a short mnemonic that can be associated with the concept instead of by copying the series of opcodes and arbitrary bits express. These mnemonics are referred to as "Conceptual Opcodes" because they refer to concepts instead of a specific series of bits. Conceptual opcodes are only used within the specification for the sake of convenience and cannot be used by a programmer to write Advanced Assembly code. Conceptual Opcodes are defined throughout the specification and a complete list of all conceptual opcodes and what they represent can be found in Appendix B.

----
IV. Strings

  In Advanced Assembly, a string refers to a series of bits with a length of zero or a positive multiple of four. A string is the fundamental structure of Advanced Assembly and is notated using the conceptual opcode "STRING." A string consists of the opcode CS (1) followed by four arbitrary bits. This pattern is repeated as many times as necessary in order to convey the desired string. The end of a string is indicated by the opcode ES (0) after the CS opcode and four bits pattern.  A string consisting solely of an ES opcode will have a length of zero and no defined value. It is important to note that a string refers to the collection of bits notated and does not include the CS and ES - the opcodes are used for notating a string literally within a program. However, when a program manipulates a string the manipulation refers to the notated bits and if a statement evaluates to a string, the string does not include the CS and ES opcodes.

Examples:
  ES                                      A string with a length of zero and no defined value
  CS 1001 ES                              A string with a length of four and a value of 1001
  CS 0001 CS 0010 CS 0100 CS 1000 ES      A string with a length of 16 and a value of 0001001001001000

----
V. Data Types

  All data within Advanced Assembly can be grouped into three data types: strings, integers, and floats. Several aspects of the program, such as the program's code and namespaces (see section VI) are stored as strings and can be manipulated as such. Numerical data is typically stored as either an integer or a float. Note that strings, integers, and floats are fully interchangeable.

A. Integer

  An integer is just what it sounds like: an integer. It is represented by the conceptual opcode INT. An integer consists of one bit followed by a string. The string represents the integer's value and is interpreted in a little-endian style. Therefore, the first group of four bits represents the eight, four, two, and one place values respectively; the second group of four bits represents the one hundred twenty-eight, sixty-four, thirty-two, and sixteen place values respectively; and so on and so forth. The first bit (before the STRING) is the sign bit. If it is 0, then the string integer value is determined as previously outlined. If it is 1, then the integer is negative, and the string integer value is its two's compliment: the positive value of the integer is calculated by replacing every 1 with 0 and vice versa and then incrementing the resulting integer.
  When converting a string to an integer, the first bit of the string is used as the sign bit and all subsequent bits are interpreted as the string. If the interpreted string's length is not a multiple of four, then a 0 is added to the string in the location where it would be the most significant bit. This is repeated until the string's length is a multiple of four. When converting an integer to a string, the sign bit is prepended to integer's string component and the resulting string is considered the integer's string value.

Examples:
  0 ES                                       An integer with a value of one
  0 CS 1001 CS 0001 ES                       An integer with a value of 25
  0 CS 0000 CS 0000 CS 0000 CS 0010 ES       An integer with a value of 8192
  1 ES                                       An integer with a value of negative one
  1 CS 1110 ES                               An integer with a value of negative two
  1 CS 1111 CS 1000 ES                       An integer with a value of negative 113

B. Float

  A float is used to represent numbers that are not integers. A float is represented by the conceptual opcode FLOAT. A float consists of two integers, known as the "mantissa" and "exponent" respectively. The value of a float is determined by multiplying the mantissa by two raised to the power of the exponent. The sign of the mantissa determines the sign of the float while the sign of the exponent helps determine the magnitude of the float.
  When converting a float to an integer, the integer is initially set to the value of the mantissa. Then, the string component of the integer is augmented such that the resulting integer's magnitude is the same as the float's. If the float's exponent is positive, a number of "0"'s equal to the float's exponent is inserted into the integer's least significant digit shifting all other digits into more significant place values. If the float's exponent is negative, then the integer's least significant digit is removed an amount equal to the exponent's absolute value. Each time the least significant digit is removed, all other digits are shifted into less significant place values. If, at any point, the entire string component of the integer is removed and more digits still need to be removed, the remaining digits to be removed are to be discarded. When converting an integer into a float, the float's mantissa is set to the integer and the float's exponent is set to zero.
  When converting a string into a float, the string is divided in two. The first half of the string becomes the mantissa and the second half becomes the exponent; each string is converted to an integer via the process outlined in Section IV.B. If the string's length is odd, then the it is divided into two such that the exponent's section is one bit longer than the mantissa's section. When converting a float into a string, then both the mantissa and exponent are converted to strings and the resulting string is the string form of the exponent appended to the string form of the mantissa.

Examples:
  0 ES 0 ES                      A float with a value of zero
  0 CS 0001 ES 0 CS 1000 ES      A float with a value of 256
  1 CS 1111 ES 0 ES              A float with a value of negative one
  1 CS 0000 ES 0 CS 1010 ES      A float with a value of negative 16384
  0 CS 1010 ES 1 CS 1110 ES      A float with a value of 2.5
  0 CS 0101 ES 1 CS 1000 ES      A float with a value of 0.01953125
  1 CS 1010 ES 1 CS 1101 ES      A float with a value of negative 0.625
  1 CS 0011 ES 1 CS 1100 ES      A float with a value of negative 0.1875

----
VI. Namespaces

  Namespaces are a hierarchical structure--namespaces are grouped via parent-child relationships--used for storing data. A namespace is represented by the conceptual opcode NMSP. Every namespace has a name, a value, and a parent namespace. A namespace's name and parent uniquely identify it. At the top of namespace hierarchy is the Global Namespace; all other namespaces either have the Global Namespace as a parent or as a more distant ancestor. Under certain circumstances, the parent of the Global Namespace may be referenced: the Global Namespace is the parent of the Global namespace.
  Initially, every namespace has a value of an empty string; however, throughout a program's execution, a namespace may be assigned another value. A namespace will maintain the value it is assigned in the form it is assigned (so if a namespace is assigned a float value, the namespace will have the value of the float--the float will not be converted to another type), however any namespace may be interpreted as any type. If a namespace is interpreted as a type other than the type of its current value, the value will be converted to the appropriate type.
  Since all statements within an Advanced Assembly program are expressed as a series of bits, a program's code is stored in a namespace as a string. When stored as a string, the string's value includes the opcodes used for describing a namespace's structure (outlined below). Any namespace can be interpreted as a fully functional Advanced Assembly program and run as such. If a namespace is run as a program and its value is not a string, then the namespace's value is converted to a string before being run. Because of this, the Global Namespace, unlike all other namespaces, does not start with an initial value of an empty string. Instead, the Global Namespace starts with a string value that contains the currently run program. When actions in Advanced Assembly are executed, the namespace that contains the binary string being interpreted as the action is considered the "Current Namespace." Every program starts with the Global Namespace as the Current Namespace. For additional details on how a namespace is executed as a program and special cases that may arise, see *Section VII.
  Namespaces can be written in two formats: absolute and relative. Absolute namespaces are prefaced by the opcode AN (0). Then the namespace consists of groups of the CN (1) opcode and a STRING. After an arbitrary amount of groups, the EN (0) opcode is encountered indicating the end of the namespace definition. After the AN opcode, the Global Namespace is referenced. Each subsequent group references the child namespace of the previously referenced namespace with the specified STRING as its name. When the EN opcode is encountered, the last referenced namespace is the namespace being referenced by the NMSP statement. Note that by including no CN and STRING groups, the Global Namespace can be referenced.

Examples:
  AN EN                                         References the Global Namespace
  AN CN CS 0000 ES EN                           References a child of the Global Namespace called "0000"
  AN CN CS 0101 ES CN CS 0000 CS 1111 ES EN     References the Global Namespace's child "0101"'s child "00001111"

  Alternatively, a namespace can be referenced by its relation to the Current Namespace. Relative namespaces are prefaced by the opcode RN (1). The the namespace consists of groups of the CN (1) opcode and a STRING, or the PN (01) opcode. After an arbitrary amount of groups, the ERN (00) opcode is encountered indicating the end of the namespace definition. After an RN opcode, the Current Namespace is identified. Each subsequent group of CN and STRING encountered references the child namespace of the previously referenced namespace with the specified STRING as its name. Alternatively, the PN opcode may be encountered in which case the parent of the last referenced namespace is referenced. When the ERN opcode is encountered the last referenced namespace is the namespace being referenced by the NMSP statement. Note that by only including the RN and ERN opcodes, the Current Namespace can be referenced.
  While absolute namespaces and relative namespaces can be used interchangeably under most circumstances, relative namespaces that are a direct child of the Current Namespace are a special case and are a separate entity from the homophonic namespace--the namespace with the same name and parent--that would be referred to absolutely. These namespaces are called "temporary namespaces." Note that the child of a child of the Current Namespace (or a more distant child) is NOT a temporary namespace. Note that before a value is assigned to a temporary namespace, references to the temporary namespace will be referred to the homophonic namespace (e.g. if a temporary namespace 0000 has not had a value assigned to it, but the homophonic namespace 0000's value is a string with the value "0101", then references to the value of the temporary namespace will evaluate to the value of the homophonic namespace: "0101" and not evaluate to the value of an unassigned namespace--an empty string; of course, if neither the temporary namespace nor the homophonic namespace have a value assigned then the value of the temporary namespace will evaluate to an empty string).
  Once a value is assigned to a temporary namespace, the value can only be accessed from the namespace that assigned the value. Not only is this value unique to the namespace that assigned it, but it is also unique to the version of the namespace that assigned it: thus allowing for recursion. For example: given the program is in the Current Namespace 0000 and the program stores a string with the value "1" in the temporary namespace 0001 (a child of namespace 0000). Then, if the program recurses and transfers execution to the beginning of namespace 0000 the new context means that the temporary namespace 0001 will have a value of an empty string (the default value) and not "1." When execution returns to namespace 0000 in the original context, the temporary namespace 0001 will regain its former value of "1." 

Examples:
  RN ERN                                  References the Current Namespace
  RN PN ERN                               References the Current Namespace's parent
  RN PN CN CS 0000 ES ERN                 References the child "0000" of the Current Namespace's parent. If the current namespace's name is "0000" then this would be referencing the Current Namespace
  RN PN CN CS 1010 ES CN CS 1111 ES ERN   References the Current Namespace's parent's child "1010"'s child "1111." If the current namespace's name is "1010," then this is referencing the temporary namespace "1111"
  RN CN CS 0101 ES ERN                    References the Current Namespace's child "0101"
  RN CN CS 1010 ES CN CS 1111 ES ERN      References the Current Namespace's child "1010"'s child "1111"

----
VII. Statements

  A statement consists of one or more operations that evaluate to a value: either an int, float or string (strings may be used to represent namespaces; see Section VI). A complete statement is represented by the conceptual opcode STMT. Statements are broken up into two types: literal statements which evaluate to the literal value of their contents, and functional statements which evaluate to a value derived from one or more other statements.

A. Literal Statements

  Literal statements are statements that have a single input and evaluate to the literal value of that input. All literal statements start with the opcode LS (0). After the LS opcode, their are three options. The first is a string literal statement which consists of the opcode LT (0) followed by a STRING. The second option is the opcode LI (10) followed by an INT. The final option is the opcode LF (11) followed by a FLOAT. Each type of literal statement evaluates to the value delineated within the statement.

Examples:
  LS LT CS 0000 ES                    Evaluates to a string with a value of "0000"
  LS LI 0 CS 0001 ES                  Evaluates to an int with a value of 1
  LS LF 0 CS 0001 ES 1 CS 1111 ES     Evaluates to a float with a value of 0.5

B. Functional Statements

  Functional statements are statements that have one or more inputs and evaluate to a value derived from them. All functional statements start with the opcode FS (1). Functional statements can be further divided into two categories: namespace statements which derive their value from manipulating namespaces, and mathematical statements which derive their value from a mathematical manipulation of one or more inputs.

1. Namespace Statements

  Namespace statements are the most complex statements and involve manipulating namespaces. They are also the most important section of any program and are what allow an Advanced Assembly program to make changes to the program's state. After the FS opcode, all namespace statements have the NS (0) opcode. After the NS opcode, there are three possible types of namespace statements.
  The first two types of namespace statement are relatively simple and directly manipulate the value of a namespace. An assign statement can be made using the AS (00) opcode followed by two additional statements. The first of these statements' value is converted to a string (if it is not a string already) and is then interpreted as a namespace. This namespace's value is then set to be whatever the second statement evaluates to. An assign statement evaluates to the value assigned to the namespace. The other simple namespace statement is a read statement which consists of the RS (01) opcode followed by one additional statement. This statement's value is then interpreted as a namespace (via a string). The read statement then evaluates to the value of the designated namespace.
  The final type of namespace statement is the evaluate statement. The evaluate statement is used to transfer a program's control to another namespace. The evaluate statement starts with the ES (1) opcode followed by a varying amount of statements greater than one. The value of the first statement is interpreted as a namespace (via a string). The contents of this namespace are then interpreted as a program (via a string) which will be executed. As outlined in *Section IX, the amount of inputs to be sent to the program is derived. For each of these inputs, another statement is evaluated and the value of the current input is set to the value of the statement. Therefore, if an evaluate statement's first input indicates a namespace that contains a program with zero inputs, the evaluate statement will only consist of FS NS ES STMT. However, if the evaluate statement's first input denotes a namespace that contains a program with four inputs, the evaluate statement will consist of FS NS ES STMT STMT STMT STMT STMT. Note that there are five statements: one to identify the program and then one for each input for the program.

Examples:
  FS NS AS LS LT nmsp LS LI 0 CS 0001 ES              Assigns an int with a value of one to the namespace nmsp*. Evaluates to an int with a value of one.
  FS NS RS LS LT nmsp                                 Evaluates to namespace nmsp*'s value.
  FS NS ES LS LT nmsp LS LT ES LS LT ES LS LT ES      Executes the program at namespace nmsp* that has three arguments. Each argument is set to an empty string. The statement evaluates to the result of the program at nmsp*.

*For simplicity's sake, rather than writing out a string that denotes a namespace verbatim, the acronym nmsp is used to denote a string that contains an arbitrary namespace. 
 
2. Mathematical Statements

  Mathematical statements are the most diverse set of statements. All mathematical statements start with the MS (1) opcode followed by one of the "operation opcodes" and then by either one or two statements. Operation opcodes are a long list of opcodes outlined below that indicate of the mathematical operations that can be performed. The first statement after the operation opcode is the first input for the operation opcode and the second statement is the second input for the operation opcode. Some operation opcodes only have one input and in that case, only one statement will be read after the operation opcode.
  If only one input is required, the result will be the same type as the input. If two inputs are required, then result is more complicated. If both inputs for an operation are of type int, then the result will be of type int. If both inputs are of type float, then the result will be of type float. If one input is an int and the other a float, the int will be converted to a float and the inputs will be handled like two floats. If one input is a string and the other an int, the string will be converted to an int and the inputs will be handled like two ints. If one input is a string and the other is a float, the string will be converted to a float and the inputs will be handled like two floats.  If both inputs are strings, then, in general, the strings will be converted to floats, processed accordingly, and then the result will be converted back to a float. However, in certain circumstances this behavior will be different.
  The simplest operation opcodes are OP (0000) for addition, OM (0001) for subtraction, OT (0010) for multiplication, and OD (0011) for division. The addition opcode (OP) evaluates to the sum of the two inputs. If both inputs for the addition opcode are strings, the result will be a string that is equal to the second input appended to the first input. The multiplication opcode (OM) evaluates to the product of the two inputs. The subtraction opcode (OM) evaluates to the second input subtracted from the first input. The division opcode (OD) evaluates to the quotient of the first input divided by the second input. If the second input is zero, than the result is an empty string to indicate that division by zero (a mathematically undefined situation) has occurred.
  The next two operational opcodes provide two other standard mathematical capabilities: modulus and exponentiation. The exponentiation opcode, OE (0100) evaluates to the first input raised to the power of the second input. The modulus opcode OU (0101) evaluates to the positive difference between the first input and the largest multiple of the second input less than the first input.

  The first four opcodes that can be used in an operational expression are the standard arithmetic operations: addition, subtraction, multiplication, and division. They are represented by the ADD (000), SUB (001), MULT (010), and DIV (011) opcodes respectively. The ADD opcode and MULT opcode add and multiply the two EXPRs' values respectively. The SUB opcode subtracts the second EXPR's value from the first EXPR's value and the DIV opcode divides the first EXPR's value by the second EXPR's value. If the second EXPR's value is zero, then the result of division is undefined. To avoid errors, the expression will evaluate to zero.

  The next three opcodes that can be used in an operational expression are the basic bitwise operations: bitwise and, bitwise or, and bitwise xor. They are represented by the BTAND (100), BTOR (1010), and BTXOR (1011) opcodes respectively. In a bitwise operations between two integers, corresponding bits in the two integers are compared appropriately and then the resulting value is used in the corresponding bit in the resulting integer. Note that corresponding bits means bits with the same value so bits with a value of 2 are compared and bits with a value of 4 are compared but a bit with a value of 2 in one integer is never compared to a bit with a value of 4 in another integer. In cases where one integer is longer than the other, leading 0 bits are assumed to allow for the integers to have the same length. Similarly, when bitwise operations are performed on two decimals, corresponding bits are compared and 0 bits are assumed when a bit is missing. It is important to note, however, that corresponding bits in a decimal are based on the bits VALUE not on its location. This means that the exponent is not compared in bitwise operations with decimals but is instead used to figure out which bits in the significand correspond between the two. Finally, in cases when an integer and a decimal are being used in bitwise operations, the integer is converted into a decimal of equivalent value and then the operation is performed as if with two decimals.

  The last two bitwise opcodes are BTLFT (1100) and BTRT(1101) which are used for left bit shifts and right bit shifts respectively. The first argument for the bit shift is the number being shifted and the second argument is the number of bits to shift the number. The second number must be an integer, so if a decimal is provided it will be converted into the largest integer less than or equal to the decimal. If the second number is negative, then the expression is interpreted as a bit shift in the opposite direction. In a left bit shift, the second number is used to determine how many 0 bits will be appended to the first number effectively multiplying the number by 2 raised to the power of the second number. If the first number is a decimal, the zeroes will be appended to the significand not the exponent. In a right bit shift, the second number determines how many bits will be removed from the end of the number. While this is similar to dividing by 2 raised to the power of the second number, it is important to distinguish the two because in a right bit shift, the remainder is discarded. Furthermore, if the first number is a decimal the changes are applied to the significand leading to parts of the decimal being lost. Finally, if a right shift can not remove more bits than exist in the number. If the second number is larger then the length of the first number, this expression will evaluate to 0.

  The last two opcodes are MOD (1110) and EXP (1111) which are used to perform modulus and exponentiation respectively. The modulus operation evaluates to the difference between the largest multiple of the second number smaller than the first number and the first number. When both numbers are integers this is equivalent to calculating the remainder of the euclidean division of the first integer by the second integer. If the second number is zero, than the expression is undefined. To avoid errors, the expression will still evaluate to zero. The exponentiation operation evaluates to the first number raised to the power of the second number. Under certain circumstances (like negative one being raised to the one half power) the result of this operation may be undefined or imaginary. To avoid errors, the expression will simply evaluate to zero.

----
VII. Actions

A. Global Statements

1. Set Variable

2. Invoke Function

B. Restricted Statements

1. If Else

2. Switch

3. While

4. For

5. Return

----
VIII. Functions

----
IX. Classes

----
Appendix A. Opcodes

  This section consists of a list of all opcodes and their values. The opcodes are grouped up by the section they are explained in.

  Strings (Section IV)
ES                 0
CS                 1

  Namespaces (Section VI)
AN                 0
RN                 1
EN                 0
CN                 1
ERN                00
PN                 01

  Statements (Section VII)
LS                 0
LT                 0
LI                 10
LF                 11
FS                 1
NS                 0
AS                 00
RS                 01
ES                 1
MS                 1

  Operation Opcodes (Section VII.B.2)
OP                 0000
OM                 0001
OT                 0010
OD                 0011
OE                 0100
OU                 0101

----
Appendix B. Conceptual Opcodes

  STRING             Represents a string. See Section IV
  INT                Represents an integer. See Section V.A
  FLOAT              Represents a float. See Section V.B
  NMSP               Represents a namespace. See Section VI
  STMT               Represents a complete statement. See Section VII
