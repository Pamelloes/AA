================================================================
==    ADVANCED ASSEMBLY LANGUAGE SPECIFICATION VERSION 0.4    ==
================================================================

----
I. Preface

  Advanced Assembly is a programming language roughly resembling an assembly programming languages. However, unlike standard assembly languages, Advanced Assembly is not designed to be run on a specific processor. Instead, it has been designed so that any series of bits--any combination of "1" and "0"--is a valid program.
  A key design element of Advanced Assembly is that it discards the standard grouping of eight bits into a byte--this allows Advanced Assembly to be able to interpret any series of bits as a program but also makes it impossible to run directly on a processor. Instead, Advanced Assembly code must be run via an interpreter, ostensibly on a virtual machine.
  During earlier stages of development, Advanced Assembly was called High Level Binary, and, in addition to being able to interpret any series of bits as a program, was intended to be able to express a myriad of high-level programming features reminiscent of programming languages like C++ or Python. However, as development progressed, it became apparent that in order to implement many features the syntax of the language would become incredibly complicated and that they could be replicated in code within a simpler language. As such, the language was rapidly simplified until by the time the first complete language specification was planned out, High Level Binary no longer represented the "high level" programming languages it was originally intended to emulate; instead, the programming language appeared to be a permutation of a typical assembly language. Therefore, the decision was made to rename the language Advanced Assembly to indicate that it facilitated a different feature set than standard assembly languages while distancing the association with so-called high level programming languages.
  The simplification of Advanced Assembly has led to several features that were believed to be very important to no longer directly included in the programming language. These features, such as the Object Oriented Programming paradigm, will therefore be provided as "extensions." Separate specification documents will be drafted that define how these features are to work and a reference implementation of them shall be created solely using Advanced Assembly code. Therefore in a program where one of these features is desired, the extension can be used by invoking the extension as one of the first actions of a program. All subsequent statements will than have access to the now-loaded extension's feature set. As of the writing of this document, no extensions have been drafted or implemented.
  
----
II. Table of Contents

  I.             Preface
  II.            Table of Contents
  III.           Notation
   A.             Opcodes
  IV.            Strings
  V.             Structure Types
   A.             Primitives
   B.             Objects
  VI.            Variables
  VII.           Expressions
  VII.           Statements
   A.             Global Statements
    1.             Set Variable
    2.             Invoke Function
   B.             Restricted Statements
    1.             If Else
    2.             Switch
    3.             While
    4.             For
    5.             Return
  VIII.          Functions
  IX.            Classes


  Appendix A.    Opcodes
  Appendix B.    Conceptual Opcodes

----
III. Notation

  Advanced Assembly, as a quasi-assembly language, is programmed by specifying the value of a series of bits. A bit is the smallest unit of memory within a computer and can either have a value of "0" or "1." Throughout this document it is understood that "1" and "0" do not refer to their numerical value. Instead, "1" represents a single bit with a value of one and "0" represents a single bit with a value of zero. All other arabic numerals are understood to be referring to their numeric value. In the event that "1" or "0" is used in conjunction with other arabic numerals, it is understood that the "1" or "0" will not be representing their numeric value and not a computer bit.
  Under some circumstances, expressing numbers (such as one hundred) in arabic numerals will only use the symbols "1" and "0". In such cases, the number will be written out "one hundred." Therefore, if "100" is encountered it is understood that "100" is referring to three, sequential bits with values of one, zero, and zero respectively.

Examples:
     0  Refers to a single bit with a value of zero
     8  Refers to the number eight
    10  Refers to two, sequential bits with values of one and zero respectively
    15  Refers to the number fifteen
  1425  Refers to the number one thousand, four hundred, twenty-five
  1000  Refers to four, sequential bits with values of one, zero, zero, and zero respectively

NOTE: In many documents strings of bits may be grouped into sets of four and expressed in hexadecimal--allowing two hexadecimal digits to express the value of a byte. However, since Advanced Assembly does not group bits into larger groups of regular size, this notation will not be used. Whenever strings of bits are to be expressed, they will be expressed using the previously outlined "1" and "0" notation.

A. Opcodes

  While the Advanced Assembly programming language is made up of series of 1's and 0's, such notation can be difficult for humans to read. Furthermore, the character "1" is not equal to a single bit a value of one. Instead, characters are made up of groups of 8 bits so rendering an Advanced Assembly program as text would produce gibberish.
  In order to solve this problem and allow for easier programming, the various aspects of Advanced Assembly are defined through mnemonics--several character abbreviations that directly transfer to a specific series of bits. A separate program can then be used to turn a text file consisting of these mnemonics into their corresponding bits. These mnemonics are collectively referred to as "opcodes" and are defined throughout the specification. A complete list of all the defined opcodes in Advanced Assembly and their corresponding values can be found in Appendix A.
  In Advanced Assembly, groups of opcodes are used in conjunction with arbitrary series of bits in predictable patterns to express more complex concepts than a set of opcodes that directly correspond with a series of bits. These concepts, such as strings, often come up in multiple places throughout the specification where it is more meaningful to refer to them by a short mnemonic that can be associated with the concept instead of by copying the series of opcodes and arbitrary bits express. These mnemonics are referred to as "Conceptual Opcodes" because they refer to concepts instead of a specific series of bits. Conceptual opcodes are only used within the specification for the sake of convenience and cannot be used by a programmer to write Advanced Assembly code. Conceptual Opcodes are defined throughout the specification and a complete list of all conceptual opcodes and what they represent can be found in Appendix B.

----
IV. Strings

  In Advanced Assembly, a string refers to a series of bits. A string is the fundamental structure of Advanced Assembly and is notated using the conceptual opcode "STRING." A string is made of several groups of the opcode CS (1) followed by four arbitrary bits, ultimately terminated by the opcode ES (0). Each group of CS followed by four arbitrary bits adds the value of the four arbitrary bits to the string's value. So the value of a string with one CS group will have four bits, while a string with four CS groups will have 16 bits. When writing out a string's value, the value will extend until the ES opcode is reached. Therefore, theoretically, a string can have an infinite length though implementation details will probably impose an upper limit. A string consisting solely of an ES opcode will have a length of zero and no defined value.

Examples:
  ES                                      A string with a length of zero and no defined value
  CS 1001 ES                              A string with a length of four and a value of 1001
  CS 0001 CS 0010 CS 0100 CS 1000 ES      A string with a length of 16 and a value of 0001001001001000

----
V. Structure Types

  There are a variety of different types of structures within High Level Binary. These structures can be broken down into two categories: primitives and objects. A fully qualified type is represented by the opcode TYPE.

A. Primitives

  A primitive type is a form of number. Primitive types are collectively referred to by the opcode TYPE[P]. When a primitive type is identified by a TYPE opcode, it must be qualified by the PT opcode (0). However, when a primitive type is identified by TYPE[P] the PT qualification is omitted since only primitive types are accepted.

  The two principle primitive types are integer and decimal. Integers are identified by the opcode INT (0) and decimals by the opcode DEC (1). Therefore a fully qualified integer and decimal, respectively, would be as follows:

  PT INT
  PT DEC

B. Objects

  An object type is any structure whose data is not numerical in nature. Object types are referred to collectively by the opcode TYPE[O]. When an object type is identified by a TYPE opcode, it must be qualified by the OT opcode (1). However, when a type is identified by TYPE[O] the OT qualification is omitted since only object types are accepted.

  The four object types are as follows: function, class, array, and instance. These types are identified by the FUN (00), CLS (01), ARR (10), and INST (11) opcodes respectively. Therefore the four types, fully qualified would be as follows:

  OT FUN
  OT CLS
  OT ARR
  OT INST

----
VI. Variables

  Variables are used to store states throughout the course of the program. Variables are identified by the VAR opcode and consist of a TYPE followed by a NAME. In certain cases a variable might be restricted to TYPE[O] or TYPE[P] in which case the opcode VAR[O] and VAR[P] will be used respectively. Therefore, a VAR, VAR[O], and VAR[P] would look like:

  TYPE NAME
  TYPE[O] NAME
  TYPE[P] NAME

  It is important to note that unlike many languages, all variables within High Level Binary are of global scope so once once a variable is set anywhere in the program it will retain its value until it is changed somewhere else in the program. Note that while whenever a variable is addressed, it is referenced by both a TYPE and a NAME, but the variable itself is identified solely by its NAME. This can lead to situations where a variable consisting of one value type is called upon to have another type. Through a process called Implicit Conversion, any type can be converted to any other type. See Appendix C. Implicit Values and Conversion for details on how this process works.

----
VII. Expressions

  Expressions are combinable statements that evaluate to a number and are used to perform mathematical operations. Expressions come in two forms: numerical and operational. All operations are referred to collectively by the opcode EXPR.

A. Numerical Expressions

  Numerical expressions are expressions that evaluate a single argument to a single result. Numerical expressions are qualified by the opcode EXN (0) and are referred to collectively by the opcode EXPR[N]. When a numerical expression is denoted by the opcode EXPR[N], the EXN qualification is omitted. There are four numerical expression types: integer literal, decimal literal, bitwise not, and variable.

  The integer literal numerical expression consists of the opcode LINT (00) followed by a STRING. The integer literal interprets the STRING as an n-bit, two's compliment integer allowing for the full range of integers to be expressed. For example, a fully qualified integer literals that would evaluate to 16, -32, and 27 respectively would be as follows:

  EXN LINT LF 0001 CS 0000 ES
  EXN LINT SF 11100000
  EXN LINT LF 0001 CS 1011 ES

  The decimal literal expression consists of the opcode LDEC (01) followed by two STRINGs. The first STRING represents the significand and the second STRING represents the exponent. Both STRINGs will be interpreted as n-bit, two's compliment integers allowing for the full range of real numbers to be expressed. For example, a fully qualified decimal literal that would evaluate to 2.75, 31.375 and 4.9375 respectively would be as follows:

  EXN LDEC SF 00001011 LF 1110 ES
The first STRING evaluates to eleven and the second STRING evaluates to -2. Eleven * 2^(-2) = Eleven/4 = 2.75
  EXN LDEC LF 0000 CS 1111 CS 1011 ES LF 1101 ES
The first STRING evaluates to 251 and the second STRING evaluates to -3. 251*2^(-3) = 251/8 = 31.375
  EXN LDEC SF 01001111 LF 1100 ES
The first STRING evaluates to 79 and the second STRING evaluates to -4. 79*2^(-4) = 79/16 = 4.9375

  A bitwise not expression consists of the opcode BTWN (10) followed by an EXPR. The value of the embedded OPER will be inverted (each 0 will become 1 and vice versa). Therefore a fully qualified bitwise not expression is simply:

  EXN BTWN EXPR

  Finally, the variable expression is used to retrieve the value of a variable. A variable expression consists of the EVAR opcode (11) followed by a VAR[P]. Note that in some cases the retrieval of a variable's value requires additional parameters to be passed (e.g. if the variable holds a function). Each necessary additional parameter will be expressed as an EXPR following the VAR[P]. For instance, a variable expression with zero, three, and four additional parameters respectively would be as follows:

  EXN EVAR VAR[P]
  EXN EVAR VAR[P] EXPR EXPR EXPR
  EXN EVAR VAR[P] EXPR EXPR EXPR EXPR

B. Operational Expressions

  Operational expressions are expressions that evaluate two arguments to a single result. Operational expressions are qualified by the opcode EXO (1) and are referred to collectively by the opcode EXPR[O]. When an operational expression is denoted by the opcode EXPR[O], the EXO qualification is omitted. All operational expressions are identical consisting of the EXO qualifier followed by an opcode indicating which operation will be performed and then two EXPRs that represent the first and second value being used by the operation. Therefore, all operational expression look like the following (where [opcode] represents one of the eleven opcodes that will be discussed later in this section):

  EXO [opcode] EXPR EXPR

  The first four opcodes that can be used in an operational expression are the standard arithmetic operations: addition, subtraction, multiplication, and division. They are represented by the ADD (000), SUB (001), MULT (010), and DIV (011) opcodes respectively. The ADD opcode and MULT opcode add and multiply the two EXPRs' values respectively. The SUB opcode subtracts the second EXPR's value from the first EXPR's value and the DIV opcode divides the first EXPR's value by the second EXPR's value. If the second EXPR's value is zero, then the result of division is undefined. To avoid errors, the expression will evaluate to zero.

  The next three opcodes that can be used in an operational expression are the basic bitwise operations: bitwise and, bitwise or, and bitwise xor. They are represented by the BTAND (100), BTOR (1010), and BTXOR (1011) opcodes respectively. In a bitwise operations between two integers, corresponding bits in the two integers are compared appropriately and then the resulting value is used in the corresponding bit in the resulting integer. Note that corresponding bits means bits with the same value so bits with a value of 2 are compared and bits with a value of 4 are compared but a bit with a value of 2 in one integer is never compared to a bit with a value of 4 in another integer. In cases where one integer is longer than the other, leading 0 bits are assumed to allow for the integers to have the same length. Similarly, when bitwise operations are performed on two decimals, corresponding bits are compared and 0 bits are assumed when a bit is missing. It is important to note, however, that corresponding bits in a decimal are based on the bits VALUE not on its location. This means that the exponent is not compared in bitwise operations with decimals but is instead used to figure out which bits in the significand correspond between the two. Finally, in cases when an integer and a decimal are being used in bitwise operations, the integer is converted into a decimal of equivalent value and then the operation is performed as if with two decimals.

  The last two bitwise opcodes are BTLFT (1100) and BTRT(1101) which are used for left bit shifts and right bit shifts respectively. The first argument for the bit shift is the number being shifted and the second argument is the number of bits to shift the number. The second number must be an integer, so if a decimal is provided it will be converted into the largest integer less than or equal to the decimal. If the second number is negative, then the expression is interpreted as a bit shift in the opposite direction. In a left bit shift, the second number is used to determine how many 0 bits will be appended to the first number effectively multiplying the number by 2 raised to the power of the second number. If the first number is a decimal, the zeroes will be appended to the significand not the exponent. In a right bit shift, the second number determines how many bits will be removed from the end of the number. While this is similar to dividing by 2 raised to the power of the second number, it is important to distinguish the two because in a right bit shift, the remainder is discarded. Furthermore, if the first number is a decimal the changes are applied to the significand leading to parts of the decimal being lost. Finally, if a right shift can not remove more bits than exist in the number. If the second number is larger then the length of the first number, this expression will evaluate to 0.

  The last two opcodes are MOD (1110) and EXP (1111) which are used to perform modulus and exponentiation respectively. The modulus operation evaluates to the difference between the largest multiple of the second number smaller than the first number and the first number. When both numbers are integers this is equivalent to calculating the remainder of the euclidean division of the first integer by the second integer. If the second number is zero, than the expression is undefined. To avoid errors, the expression will still evaluate to zero. The exponentiation operation evaluates to the first number raised to the power of the second number. Under certain circumstances (like negative one being raised to the one half power) the result of this operation may be undefined or imaginary. To avoid errors, the expression will simply evaluate to zero.

----
VII. Statements

A. Global Statements

1. Set Variable

2. Invoke Function

B. Restricted Statements

1. If Else

2. Switch

3. While

4. For

5. Return

----
VIII. Functions

----
IX. Classes

----
Appendix A. Opcodes

  Strings
ES                 0
CS                 1

----
Appendix B. Conceptual Opcodes

  STRING             Represents a string. Consists of an arbitrary amount of CS opcodes (each followed by four arbitrary bits) terminated by an ES opcode.
