================================================================
==    HIGH LEVEL BINARY LANGUAGE SPECIFICATION VERSION 0.3    ==
================================================================

----
I. Preface

----
II. Table of Contents

  I.             Preface
  II.            Table of Contents
  III.           Notation
  IV.            Strings
   A.             Fixed Length Strings
   B.             Variable Length Strings
   C.             Names
  V.             Structure Types
   A.             Primitives
   B.             Objects
  VI.            Variables
  VII.           Expressions
  VII.           Statements
   A.             Global Statements
    1.             Set Variable
    2.             Invoke Function
   B.             Restricted Statements
    1.             If Else
    2.             Switch
    3.             While
    4.             For
    5.             Return
  VIII.          Functions
  IX.            Classes


  Appendix A.    Opcodes
  Appendix B.    Special Variables
  Appendix C.    Implicit Values and Conversion

----
III. Notation

  High Level Binary is a language expressed explicitly in strings of binary, a one or zero. Throughout this document it is understood that a "1" represents a binary one and a "0" represents a binary 0. All other arabic numerals are understood to not be referring to binary. In the event that "1" or "0" is used in conjunction with other arabic numerals, it is understood that they will not be referring to binary numbers. In places where the use of "1" and "0" as a base ten number or as a binary string is ambiguous, the symbols "1" and "0" will be used to refer to a binary string and the number will be written out. For instance "10" means a binary string of 1 followed by 0 and "ten" refers to the number ten. "10" will never refer to ten and "ten" will never refer to 10. Furthermore the number 170 can be assumed to be referring to the number one hundred seventy because "7" is not a valid binary symbol.

  Due to the difficulty of distinguishing various binary strings, often times binary strings will be assigned two to four letter opcodes (for instance FN refers to the binary string "010"). After an opcode is defined, it will be used instead of its corresponding binary string. A list of all opcodes and their definitions is available at the end of this document. It is important to note that codes are not exclusive; an opcode always refers to a specific binary string, but that binary string does not always refer to the opcode.

----
IV. Strings

  Unlike most high level languages, a string within High Level Binary does not refer to a series of characters. In High Level Binary, a string refers to a series of bits. Strings come in two basic types: fixed length and variable length.

A. Fixed Length Strings

  Fixed length strings are referred to by the opcode STRING[L] where L is a decimal number indicating how many bits long the string will be. For instance, a 7 bit, fixed length string would be expressed using the opcode STRING[7] and a ten bit string would be referred to by the opcode STRING[ten]. Note that, the arabic numeral form of ten is indistinguishable from the binary string 10 so ten must be written out verbatim to avoid ambiguity.

  Fixed length strings are simply a series of bits without qualification. For instance STRING[4] would simply refer to four arbitrary bits and STRING[9] would refer to nine arbitrary bits. Some example strings:

  STRING[1]: 1
  STRING[2]: 01
  STRING[7]: 0010100
  STRING[22]: 0010101011111010101100

B. Variable Length Strings

  In many cases, the length of a string is arbitrary in which case a variable length string is used. Variable length strings are defined by the opcode STRING. Variable length strings can be expressed either in short form or long form. Short form strings are qualified by the SF opcode (0) followed by a STRING[8]. Note that while the length of a variable length string is not fixed, a short form variable length string will always have a length of 8. Some example strings:

  SF 00000000
  SF 11111111
  SF 01010101

  Long form names can be used to express strings with a length that is a multiple of four. Long form names are qualified by the LF opcode (1) followed by groups of STRING[4]. After every STRING[4], either an ES opcode (0) will be reached indicating that the end of the variable length string has been reached or a CS opcode (1) will be reached indicating that 4 more bits will be specified. For instance, a 4 bit name would be expressed as follows:

  LF STRING[4] EN

Or a 12 bit name:

  LF STRING[4] CN STRING[4] CN STRING[4] EN

  It is important to understand that while short form and long form variable length strings can be used interchangeably, they are only equivalent at eight bit lengths. A long form string with any length other than eight will never be equal to a short form variable length string. This includes long form strings of length four!

  It is important to note that short and long form names are interchangeable. The first four bits of a long form name correspond with the first half of a short form name. Similarly, the second eight bits of a long form name correspond with the second half of a short form name. Note that in any name, trailing zeroes are ignored so each of the following pairs of names are equivalent:

  SF 00010000
  LF 0001 EN

  SF 01010101
  LF 0101 CN 0101 EN

  SF 01010100
  LF 0101 CN 0100 CN 0000 CN 0000 EN

C. Names

  A special subset of Strings are names. A name is used to identify various structures within High Level Binary. A name is identical in form to a variable length string. The opcode NAME will be used to refer to names indicating that the variable length string in this context will be used to name a structure.

----
V. Structure Types

  There are a variety of different types of structures within High Level Binary. These structures can be broken down into two categories: primitives and objects. A fully qualified type is represented by the opcode TYPE.

A. Primitives

  A primitive type is a form of number. Primitive types are collectively referred to by the opcode TYPE[P]. When a primitive type is identified by a TYPE opcode, it must be qualified by the PT opcode (0). However, when a primitive type is identified by TYPE[P] the PT qualification is omitted since only primitive types are accepted.

  The two principle primitive types are integer and decimal. Integers are identified by the opcode INT (0) and decimals by the opcode DEC (1). Therefore a fully qualified integer and decimal, respectively, would be as follows:

  PT INT
  PT DEC

B. Objects

  An object type is any structure whose data is not numerical in nature. Object types are referred to collectively by the opcode TYPE[O]. When an object type is identified by a TYPE opcode, it must be qualified by the OT opcode (1). However, when a type is identified by TYPE[O] the OT qualification is omitted since only object types are accepted.

  The four object types are as follows: function, class, array, and instance. These types are identified by the FUN (00), CLS (01), ARR (10), and INST (11) opcodes respectively. Therefore the four types, fully qualified would be as follows:

  OT FUN
  OT CLS
  OT ARR
  OT INST

----
VI. Variables

  Variables are used to store states throughout the course of the program. Variables are identified by the VAR opcode and consist of a TYPE followed by a NAME. In certain cases a variable might be restricted to TYPE[O] or TYPE[P] in which case the opcode VAR[O] and VAR[P] will be used respectively. Therefore, a VAR, VAR[O], and VAR[P] would look like:

  TYPE NAME
  TYPE[O] NAME
  TYPE[P] NAME

  It is important to note that unlike many languages, all variables within High Level Binary are of global scope so once once a variable is set anywhere in the program it will retain its value until it is changed somewhere else in the program. Note that while whenever a variable is addressed, it is referenced by both a TYPE and a NAME, but the variable itself is identified solely by its NAME. This can lead to situations where a variable consisting of one value type is called upon to have another type. Through a process called Implicit Conversion, any type can be converted to any other type. See Appendix C. Implicit Values and Conversion for details on how this process works.

----
VII. Expressions

  Expressions are combinable statements that evaluate to a number and are used to perform mathematical operations. Expressions come in two forms: numerical and operational. All operations are referred to collectively by the opcode EXPR.

A. Numerical Expressions

  Numerical expressions are expressions that evaluate a single argument to a single result. Numerical expressions are qualified by the opcode EXN (0) and are referred to collectively by the opcode EXPR[N]. When a numerical expression is denoted by the opcode EXPR[N], the EXN qualification is omitted. There are four numerical expression types: integer literal, decimal literal, bitwise not, and variable.

  The integer literal numerical expression consists of the opcode LINT (00) followed by a STRING. The integer literal interprets the STRING as an n-bit, two's compliment integer allowing for the full range of integers to be expressed. For example, a fully qualified integer literals that would evaluate to 16, -32, and 27 respectively would be as follows:

  EXN LINT LF 0001 CS 0000 ES
  EXN LINT SF 11100000
  EXN LINT LF 0001 CS 1011 ES

  The decimal literal expression consists of the opcode LDEC (01) followed by two STRINGs. The first STRING represents the significand and the second STRING represents the exponent. Both STRINGs will be interpreted as n-bit, two's compliment integers allowing for the full range of real numbers to be expressed. For example, a fully qualified decimal literal that would evaluate to 2.75, 31.375 and 4.9375 respectively would be as follows:

  EXN LDEC SF 00001011 LF 1110 ES
The first STRING evaluates to eleven and the second STRING evaluates to -2. Eleven * 2^(-2) = Eleven/4 = 2.75
  EXN LDEC LF 0000 CS 1111 CS 1011 ES LF 1101 ES
The first STRING evaluates to 251 and the second STRING evaluates to -3. 251*2^(-3) = 251/8 = 31.375
  EXN LDEC SF 01001111 LF 1100 ES
The first STRING evaluates to 79 and the second STRING evaluates to -4. 79*2^(-4) = 79/16 = 4.9375

  A bitwise not expression consists of the opcode BTWN (10) followed by an EXPR. The value of the embedded OPER will be inverted (each 0 will become 1 and vice versa). Therefore a fully qualified bitwise not expression is simply:

  EXN BTWN EXPR

  Finally, the variable expression is used to retrieve the value of a variable. A variable expression consists of the EVAR opcode (11) followed by a VAR[P]. Note that in some cases the retrieval of a variable's value requires additional parameters to be passed (e.g. if the variable holds a function). Each necessary additional parameter will be expressed as an EXPR following the VAR[P]. For instance, a variable expression with zero, three, and four additional parameters respectively would be as follows:

  EXN EVAR VAR[P]
  EXN EVAR VAR[P] EXPR EXPR EXPR
  EXN EVAR VAR[P] EXPR EXPR EXPR EXPR

B. Operational Expressions

  Operational expressions are expressions that evaluate two arguments to a single result. Operational expressions are qualified by the opcode EXO (1) and are referred to collectively by the opcode EXPR[O]. When an operational expression is denoted by the opcode EXPR[O], the EXO qualification is omitted. All operational expressions are identical consisting of the EXO qualifier followed by an opcode indicating which operation will be performed and then two EXPRs that represent the first and second value being used by the operation. Therefore, all operational expression look like the following (where [opcode] represents one of the eleven opcodes that will be discussed later in this section):

  EXO [opcode] EXPR EXPR

  The first four opcodes that can be used in an operational expression are the standard arithmetic operations: addition, subtraction, multiplication, and division. They are represented by the ADD (000), SUB (001), MULT (010), and DIV (011) opcodes respectively. The ADD opcode and MULT opcode add and multiply the two EXPRs' values respectively. The SUB opcode subtracts the second EXPR's value from the first EXPR's value and the DIV opcode divides the first EXPR's value by the second EXPR's value. If the second EXPR's value is zero, then the result of division is undefined. To avoid errors, the expression will evaluate to zero.

  The next three opcodes that can be used in an operational expression are the basic bitwise operations: bitwise and, bitwise or, and bitwise xor. They are represented by the BTAND (100), BTOR (1010), and BTXOR (1011) opcodes respectively. In a bitwise operations between two integers, corresponding bits in the two integers are compared appropriately and then the resulting value is used in the corresponding bit in the resulting integer. Note that corresponding bits means bits with the same value so bits with a value of 2 are compared and bits with a value of 4 are compared but a bit with a value of 2 in one integer is never compared to a bit with a value of 4 in another integer. In cases where one integer is longer than the other, leading 0 bits are assumed to allow for the integers to have the same length. Similarly, when bitwise operations are performed on two decimals, corresponding bits are compared and 0 bits are assumed when a bit is missing. It is important to note, however, that corresponding bits in a decimal are based on the bits VALUE not on its location. This means that the exponent is not compared in bitwise operations with decimals but is instead used to figure out which bits in the significand correspond between the two. Finally, in cases when an integer and a decimal are being used in bitwise operations, the integer is converted into a decimal of equivalent value and then the operation is performed as if with two decimals.

  The last two bitwise opcodes are BTLFT (1100) and BTRT(1101) which are used for left bit shifts and right bit shifts respectively. The first argument for the bit shift is the number being shifted and the second argument is the number of bits to shift the number. The second number must be an integer, so if a decimal is provided it will be converted into the largest integer less than or equal to the decimal. If the second number is negative, then the expression is interpreted as a bit shift in the opposite direction. In a left bit shift, the second number is used to determine how many 0 bits will be appended to the first number effectively multiplying the number by 2 raised to the power of the second number. If the first number is a decimal, the zeroes will be appended to the significand not the exponent. In a right bit shift, the second number determines how many bits will be removed from the end of the number. While this is similar to dividing by 2 raised to the power of the second number, it is important to distinguish the two because in a right bit shift, the remainder is discarded. Furthermore, if the first number is a decimal the changes are applied to the significand leading to parts of the decimal being lost. Finally, if a right shift can not remove more bits than exist in the number. If the second number is larger then the length of the first number, this expression will evaluate to 0.

  The last two opcodes are MOD (1110) and EXP (1111) which are used to perform modulus and exponentiation respectively. The modulus operation evaluates to the difference between the largest multiple of the second number smaller than the first number and the first number. When both numbers are integers this is equivalent to calculating the remainder of the euclidean division of the first integer by the second integer. If the second number is zero, than the expression is undefined. To avoid errors, the expression will still evaluate to zero. The exponentiation operation evaluates to the first number raised to the power of the second number. Under certain circumstances (like negative one being raised to the one half power) the result of this operation may be undefined or imaginary. To avoid errors, the expression will simply evaluate to zero.

----
VII. Statements

A. Global Statements

1. Set Variable

2. Invoke Function

B. Restricted Statements

1. If Else

2. Switch

3. While

4. For

5. Return

----
VIII. Functions

----
IX. Classes

----
Appendix A. Opcodes

  Strings
STRING[L]          A fixed length string of length L. Note that L is a decimal number.
STRING             A string with an arbitrary length.
NAME               Equivalent to STRING. Indicates that the STRING is naming a structure.
SF                 0
LF                 1
ES                 0
CS                 1

  Types
TYPE               A fully qualified structure type.
TYPE[P]            An arbitrary primitive type.
PT                 0
INT                0
DEC                1
TYPE[O]            An arbitrary object type.
OT                 1
FUN                00
CLS                01
ARR                10
INST               11

  Variables
VAR                An arbitrary variable.
VAR[P]             An arbitrary variable with a primitive type.
VAR[O]             An arbitrary variable with an object type.

  Expressions
EXPR               An arbitrary expression.
EXPR[N]            A numerical expression.
EXN                0
LINT               00
LDEC               01
BTWN               10
EVAR               11
EXPR[O]            An operational expression
EXO                1
ADD                000
SUB                001
MULT               010
DIV                011
BTAND              100
BTOR               1010
BTXOR              1011
BTLFT              1100
BTRT               1101
MOD                1110
EXP                1111

----
Appendix B. Special Variables

----
Appendix C. Implicit Values and Conversion